<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>taoensso.sente documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Sente</span> <span class="project-version">1.17.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>taoensso</span></div></div></li><li class="depth-2 current"><a href="taoensso.sente.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sente</span></div></a></li><li class="depth-3 branch"><a href="taoensso.sente.interfaces.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interfaces</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>packers</span></div></div></li><li class="depth-4"><a href="taoensso.sente.packers.transit.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transit</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>server-adapters</span></div></div></li><li class="depth-4 branch"><a href="taoensso.sente.server-adapters.aleph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aleph</span></div></a></li><li class="depth-4 branch"><a href="taoensso.sente.server-adapters.http-kit.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>http-kit</span></div></a></li><li class="depth-4 branch"><a href="taoensso.sente.server-adapters.immutant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>immutant</span></div></a></li><li class="depth-4 branch"><a href="taoensso.sente.server-adapters.jetty9.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jetty9</span></div></a></li><li class="depth-4 branch"><a href="taoensso.sente.server-adapters.nginx-clojure.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nginx-clojure</span></div></a></li><li class="depth-4"><a href="taoensso.sente.server-adapters.undertow.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>undertow</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.sente.html#var-*write-legacy-pack-format.3F*"><div class="inner"><span>*write-legacy-pack-format?*</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-allow-origin.3F"><div class="inner"><span>allow-origin?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-as-event"><div class="inner"><span>as-event</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-assert-event"><div class="inner"><span>assert-event</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-chsk-connect.21"><div class="inner"><span>chsk-connect!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-chsk-destroy.21"><div class="inner"><span>chsk-destroy!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-chsk-disconnect.21"><div class="inner"><span>chsk-disconnect!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-chsk-reconnect.21"><div class="inner"><span>chsk-reconnect!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-chsk-send.21"><div class="inner"><span>chsk-send!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-client-event-msg.3F"><div class="inner"><span>client-event-msg?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-debug-mode.3F_"><div class="inner"><span>debug-mode?_</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-event-msg.3F"><div class="inner"><span>event-msg?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-event.3F"><div class="inner"><span>event?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-IChSocket"><div class="inner"><span>IChSocket</span></div></a></li><li class="depth-2 branch"><a href="taoensso.sente.html#var--chsk-connect.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>-chsk-connect!</span></div></a></li><li class="depth-2 branch"><a href="taoensso.sente.html#var--chsk-disconnect.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>-chsk-disconnect!</span></div></a></li><li class="depth-2 branch"><a href="taoensso.sente.html#var--chsk-reconnect.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>-chsk-reconnect!</span></div></a></li><li class="depth-2"><a href="taoensso.sente.html#var--chsk-send.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>-chsk-send!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-make-channel-socket.21"><div class="inner"><span>make-channel-socket!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-make-channel-socket-client.21"><div class="inner"><span>make-channel-socket-client!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-make-channel-socket-server.21"><div class="inner"><span>make-channel-socket-server!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-sente-version"><div class="inner"><span>sente-version</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-server-event-msg.3F"><div class="inner"><span>server-event-msg?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-start-chsk-router.21"><div class="inner"><span>start-chsk-router!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-start-client-chsk-router.21"><div class="inner"><span>start-client-chsk-router!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-start-server-chsk-router.21"><div class="inner"><span>start-server-chsk-router!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-validate-event"><div class="inner"><span>validate-event</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.sente</h1><div class="doc"><pre class="plaintext">Channel sockets for Clojure/Script.

    Protocol  | client&gt;server | client&gt;server ?+ ack/reply | server&gt;user push
  * WebSockets:       ✓              [1]                           ✓
  * Ajax:            [2]              ✓                           [3]

  [1] Emulate with cb-uuid wrapping
  [2] Emulate with dummy-cb wrapping
  [3] Emulate with long-polling

Abbreviations:
  * chsk      - Channel socket (Sente's own pseudo "socket")
  * server-ch - Underlying web server's async channel that implement
                Sente's server channel interface
  * sch       - server-ch alias
  * uid       - User-id. An application-level user identifier used for async
                push. May have semantic meaning (e.g. username, email address),
                may not (e.g. client/random id) - app's discretion.
  * cb        - Callback
  * tout      - Timeout
  * ws        - WebSocket/s
  * pstr      - Packed string. Arbitrary Clojure data serialized as a
                string (e.g. edn) for client&lt;-&gt;server comms
  * udt       - Unix timestamp (datetime long)

Special messages:
  * Callback wrapping: [&lt;clj&gt; &lt;?cb-uuid&gt;] for [1], [2]
  * Callback replies: :chsk/closed, :chsk/timeout, :chsk/error

  * Client-side events:
      [:chsk/handshake [&lt;?uid&gt; nil[4] &lt;?handshake-data&gt; &lt;first-handshake?&gt;]]
      [:chsk/state [&lt;old-state-map&gt; &lt;new-state-map&gt;]]
      [:chsk/recv &lt;ev-as-pushed-from-server&gt;] ; Server&gt;user push
      [:chsk/ws-ping]

  * Server-side events:
      [:chsk/bad-package &lt;packed-str&gt;]
      [:chsk/bad-event   &lt;event&gt;]
      [:chsk/uidport-open  &lt;uid&gt;]
      [:chsk/uidport-close &lt;uid&gt;]
      [:chsk/ws-ping]

Channel socket state map:
  :type               - e/o #{:auto :ws :ajax}
  :open?              - Truthy iff chsk appears to be open (connected) now
  :ever-opened?       - Truthy iff chsk handshake has ever completed successfully
  :first-open?        - Truthy iff chsk just completed first successful handshake
  :uid                - User id provided by server on handshake,    or nil
  :handshake-data     - Arb user data provided by server on handshake
  :last-ws-error      - ?{:udt _ :ev &lt;WebSocket-on-error-event&gt;}
  :last-ws-close      - ?{:udt _ :ev &lt;WebSocket-on-close-event&gt;
                          :clean? _ :code _ :reason _}
  :last-close         - ?{:udt _ :reason _}, with reason e/o
                          #{nil :requested-disconnect :requested-reconnect
                           :downgrading-ws-to-ajax :unexpected}
  :udt-next-reconnect - Approximate udt of next scheduled auto-reconnect attempt

Notable implementation details:
  * core.async is used liberally where brute-force core.async allows for
    significant implementation simplifications. We lean on core.async's
    efficiency here.
  * For WebSocket fallback we use long-polling rather than HTTP 1.1 streaming
    (chunked transfer encoding). Http-kit _does_ support chunked transfer
    encoding but a small minority of browsers &amp;/or proxies do not. Instead of
    implementing all 3 modes (WebSockets, streaming, long-polling) - it seemed
    reasonable to focus on the two extremes (performance + compatibility).
    In any case client support for WebSockets is growing rapidly so fallback
    modes will become increasingly irrelevant while the extra simplicity will
    continue to pay dividends.

General-use notes:
  * Single HTTP req+session persists over entire chsk session but cannot
    modify sessions! Use standard a/sync HTTP Ring req/resp for logins, etc.
  * Easy to wrap standard HTTP Ring resps for transport over chsks. Prefer
    this approach to modifying handlers (better portability).

[4] Used to be a csrf-token. Was removed in v1.14 for security reasons.
A `nil` remains for semi-backwards-compatibility with pre-v1.14 clients.</pre></div><div class="public anchor" id="var-*write-legacy-pack-format.3F*"><h3>*write-legacy-pack-format?*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Advanced option, most users can ignore this var. Only necessary
for those that want to use Sente &lt; v1.18 with a non-standard
IPacker that deals with non-string payloads.

Details:
  Sente uses a private message format as an implementation detail
  for client&lt;-&gt;server comms.

  As part of [#398], this format is being updated to support
  non-string (e.g. binary) payloads.

  Unfortunately updating the format is non-trivial because:
    1. Both the client &amp; server need to support the same format.
    2. Clients are often served as cached cl/js.

  To help ease migration, the new pack format is being rolled out
  in stages:

    Sente &lt;= v1.16: reads  v1 format only
                    writes v1 format only

    Sente    v1.17: reads  v1 and v2 formats
                    writes v1 and v2 formats (v1 default) &lt;- Currently here

    Sente    v1.18: reads  v1 and v2 formats
                    writes v1 and v2 formats (v2 default)

    Sente &gt;= v1.19: reads  v2 format only
                    writes v2 format only

  This var controls which format to use for writing.
  Override default with `alter-var-root` or `binding`.</pre></div></div><div class="public anchor" id="var-allow-origin.3F"><h3>allow-origin?</h3><div class="usage"><code>(allow-origin? allowed-origins ring-req)</code></div><div class="doc"><pre class="plaintext">Alpha, subject to change.
Returns true iff given Ring request is allowed by `allowed-origins`.
`allowed-origins` may be `:all` or #{&lt;origin&gt; ...}.</pre></div></div><div class="public anchor" id="var-as-event"><h3>as-event</h3><div class="usage"><code>(as-event x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-assert-event"><h3>assert-event</h3><div class="usage"><code>(assert-event x)</code></div><div class="doc"><pre class="plaintext">Returns given argument if it is a valid [ev-id ?ev-data] form. Otherwise
throws a validation exception.</pre></div></div><div class="public anchor" id="var-chsk-connect.21"><h3>chsk-connect!</h3><div class="usage"><code>(chsk-connect! chsk)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-chsk-destroy.21"><h3>chsk-destroy!</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Deprecated
</pre></div></div><div class="public anchor" id="var-chsk-disconnect.21"><h3>chsk-disconnect!</h3><div class="usage"><code>(chsk-disconnect! chsk)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-chsk-reconnect.21"><h3>chsk-reconnect!</h3><div class="usage"><code>(chsk-reconnect! chsk)</code></div><div class="doc"><pre class="plaintext">Useful for reauthenticating after login/logout, etc.
</pre></div></div><div class="public anchor" id="var-chsk-send.21"><h3>chsk-send!</h3><div class="usage"><code>(chsk-send! chsk ev)</code><code>(chsk-send! chsk ev ?timeout-ms ?cb)</code><code>(chsk-send! chsk ev opts)</code></div><div class="doc"><pre class="plaintext">Sends `[ev-id ev-?data :as event]`, returns true on apparent success.
</pre></div></div><div class="public anchor" id="var-client-event-msg.3F"><h3>client-event-msg?</h3><div class="usage"><code>(client-event-msg? x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-debug-mode.3F_"><h3>debug-mode?_</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-event-msg.3F"><h3>event-msg?</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-event.3F"><h3>event?</h3><div class="usage"><code>(event? x)</code></div><div class="doc"><pre class="plaintext">Valid [ev-id ?ev-data] form?
</pre></div></div><div class="public anchor" id="var-IChSocket"><h3>IChSocket</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var--chsk-connect.21"><h3>-chsk-connect!</h3><div class="usage"><code>(-chsk-connect! chsk)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var--chsk-disconnect.21"><h3>-chsk-disconnect!</h3><div class="usage"><code>(-chsk-disconnect! chsk reason)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var--chsk-reconnect.21"><h3>-chsk-reconnect!</h3><div class="usage"><code>(-chsk-reconnect! chsk)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var--chsk-send.21"><h3>-chsk-send!</h3><div class="usage"><code>(-chsk-send! chsk ev opts)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-make-channel-socket.21"><h3>make-channel-socket!</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Platform-specific alias for `make-channel-socket-server!` or
`make-channel-socket-client!`. Please see the appropriate aliased fn
 docstring for details.</pre></div></div><div class="public anchor" id="var-make-channel-socket-client.21"><h3>make-channel-socket-client!</h3><div class="usage"><code>(make-channel-socket-client! path ?csrf-token-or-fn &amp; [{:keys [type protocol host port params headers recv-buf-or-n packer ws-kalive-ms ws-opts client-id ajax-opts wrap-recv-evs? backoff-ms-fn], :as opts, :or {type :auto, recv-buf-or-n (async/sliding-buffer 2048), packer :edn, client-id (or (:client-uuid opts) (enc/uuid-str)), wrap-recv-evs? true, backoff-ms-fn enc/exp-backoff, ws-kalive-ms (enc/ms :secs 20)}} _deprecated-more-opts])</code></div><div class="doc"><pre class="plaintext">Returns nil on failure, or a map with keys:
  :ch-recv ; core.async channel to receive `event-msg`s (internal or from
           ; clients). May `put!` (inject) arbitrary `event`s to this channel.
  :send-fn ; (fn [event &amp; [?timeout-ms ?cb-fn]]) for client&gt;server send.
  :state   ; Watchable, read-only (atom {:type _ :open? _ :uid _ :csrf-token _}).
  :chsk    ; IChSocket implementer. You can usu. ignore this.

Required arguments:
  path              ; Channel socket server route/path (typically `/chsk`)
  ?csrf-token-or-fn ; CSRF token string or (fn [])-&gt;string to match token
                    ; expected by server.

Common options:
  :type           ; e/o #{:auto :ws :ajax}. You'll usually want the default (:auto).
  :protocol       ; Server protocol, e/o #{:http :https}.
  :host           ; Server host (defaults to current page's host).
  :port           ; Server port (defaults to current page's port).
  :params         ; Map of any params to incl. in chsk Ring requests (handy
                  ; for application-level auth, etc.).
  :headers        ; Map of additional headers to include in the initiating request
                  ; (currently only for Java clients).
  :packer         ; :edn (default), or an IPacker implementation.
  :ajax-opts      ; Base opts map provided to `taoensso.encore/ajax-lite`.
  :wrap-recv-evs? ; Should events from server be wrapped in [:chsk/recv _]?
  :ws-kalive-ms   ; Ping to keep a WebSocket conn alive if no activity
                  ; w/in given msecs. Should be different to server's :ws-kalive-ms.</pre></div></div><div class="public anchor" id="var-make-channel-socket-server.21"><h3>make-channel-socket-server!</h3><div class="usage"><code>(make-channel-socket-server! web-server-ch-adapter &amp; [{:keys [recv-buf-or-n ws-kalive-ms lp-timeout-ms send-buf-ms-ajax send-buf-ms-ws user-id-fn bad-csrf-fn bad-origin-fn csrf-token-fn handshake-data-fn packer allowed-origins authorized?-fn unauthorized-fn ?unauthorized-fn], :or {ws-kalive-ms (enc/ms :secs 25), send-buf-ms-ws 30, allowed-origins :all, lp-timeout-ms (enc/ms :secs 20), csrf-token-fn (fn [ring-req] (or (:anti-forgery-token ring-req) (get-in ring-req [:session :csrf-token]) (get-in ring-req [:session :ring.middleware.anti-forgery/anti-forgery-token]) (get-in ring-req [:session "__anti-forgery-token"]))), packer :edn, unauthorized-fn (fn [_ring-req] {:status 401, :body "Unauthorized request"}), send-buf-ms-ajax 100, bad-origin-fn (fn [_ring-req] {:status 403, :body "Unauthorized origin"}), handshake-data-fn (fn [ring-req] nil), user-id-fn (fn [ring-req] (get-in ring-req [:session :uid])), recv-buf-or-n (async/sliding-buffer 1000), bad-csrf-fn (fn [_ring-req] {:status 403, :body "Bad CSRF token"})}}])</code></div><div class="doc"><pre class="plaintext">Takes a web server adapter[1] and returns a map with keys:

  :ch-recv ; core.async channel to receive `event-msg`s (internal or from clients).
  :send-fn                     ; (fn [user-id ev] for server&gt;user push.
  :ajax-post-fn                ; (fn [ring-req])  for Ring CSRF-POST + chsk URL.
  :ajax-get-or-ws-handshake-fn ; (fn [ring-req])  for Ring GET + chsk URL.

  :connected-uids ;             Watchable, read-only (atom {:ws #{_} :ajax #{_} :any #{_}}).
  :send-buffers   ; Implementation detail, read-only (atom {:ws #{_} :ajax #{_} :any #{_}}).

Security options:

  :allowed-origins   ; e.g. #{"<a href="http://site.com&quot;">http://site.com"</a>; ...}, defaults to :all. ; Alpha

  :csrf-token-fn     ; ?(fn [ring-req]) -&gt; CSRF-token for Ajax POSTs and WS handshake.
                     ; CSRF check will be skipped iff nil (NOT RECOMMENDED!).

  :authorized?-fn    ; ?(fn [ring-req]) -&gt; When non-nil, (authorized?-fn &lt;ring-req&gt;)
                     ; must return truthy, otherwise connection requests will be
                     ; rejected with (unauthorized-fn &lt;ring-req&gt;) response.
                     ;
                     ; May check Authroization HTTP header, etc.

  :?unauthorized-fn  ; An alternative API to `authorized?-fn`+`unauthorized-fn` pair.
                     ; ?(fn [ring-req)) -&gt; &lt;?rejection-resp&gt;. I.e. when return value
                     ; is non-nil, connection requests will be rejected with that
                     ; non-nil value.

Other common options:

  :user-id-fn        ; (fn [ring-req]) -&gt; unique user-id for server&gt;user push.
  :handshake-data-fn ; (fn [ring-req]) -&gt; arb user data to append to handshake evs.
  :ws-kalive-ms      ; Ping to keep a WebSocket conn alive if no activity
                     ; w/in given msecs. Should be different to client's :ws-kalive-ms.
  :lp-timeout-ms     ; Timeout (repoll) long-polling Ajax conns after given msecs.
  :send-buf-ms-ajax  ; [2]
  :send-buf-ms-ws    ; [2]
  :packer            ; :edn (default), or an IPacker implementation.

[1] e.g. `(taoensso.sente.server-adapters.http-kit/get-sch-adapter)` or
         `(taoensso.sente.server-adapters.immutant/get-sch-adapter)`.
    You must have the necessary web-server dependency in your project.clj and
    the necessary entry in your namespace's `ns` form.

[2] Optimization to allow transparent batching of rapidly-triggered
    server&gt;user pushes. This is esp. important for Ajax clients which use a
    (slow) reconnecting poller. Actual event dispatch may occur &lt;= given ms
    after send call (larger values =&gt; larger batch windows).</pre></div></div><div class="public anchor" id="var-sente-version"><h3>sente-version</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Useful for identifying client/server mismatch
</pre></div></div><div class="public anchor" id="var-server-event-msg.3F"><h3>server-event-msg?</h3><div class="usage"><code>(server-event-msg? x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-start-chsk-router.21"><h3>start-chsk-router!</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Platform-specific alias for `start-server-chsk-router!` or
`start-client-chsk-router!`. Please see the appropriate aliased fn
docstring for details.</pre></div></div><div class="public anchor" id="var-start-client-chsk-router.21"><h3>start-client-chsk-router!</h3><div class="usage"><code>(start-client-chsk-router! ch-recv event-msg-handler &amp; [{:as opts, :keys [trace-evs? error-handler]}])</code></div><div class="doc"><pre class="plaintext">Creates a simple go-loop to call `(event-msg-handler &lt;server-event-msg&gt;)`
and log any errors. Returns a `(fn stop! [])`. Note that advanced users may
prefer to just write their own loop against `ch-recv`.

Nb performance note: since your `event-msg-handler` fn will be executed
within a simple go block, you'll want this fn to be ~non-blocking
(you'll especially want to avoid blocking IO) to avoid starving the
core.async thread pool under load. To avoid blocking, you can use futures,
agents, core.async, etc. as appropriate.</pre></div></div><div class="public anchor" id="var-start-server-chsk-router.21"><h3>start-server-chsk-router!</h3><div class="usage"><code>(start-server-chsk-router! ch-recv event-msg-handler &amp; [{:as opts, :keys [trace-evs? error-handler simple-auto-threading?]}])</code></div><div class="doc"><pre class="plaintext">Creates a simple go-loop to call `(event-msg-handler &lt;server-event-msg&gt;)`
and log any errors. Returns a `(fn stop! [])`. Note that advanced users may
prefer to just write their own loop against `ch-recv`.

Nb performance note: since your `event-msg-handler` fn will be executed
within a simple go block, you'll want this fn to be ~non-blocking
(you'll especially want to avoid blocking IO) to avoid starving the
core.async thread pool under load. To avoid blocking, you can use futures,
agents, core.async, etc. as appropriate.

Or for simple automatic future-based threading of every request, enable
the `:simple-auto-threading?` opt (disabled by default).</pre></div></div><div class="public anchor" id="var-validate-event"><h3>validate-event</h3><div class="usage"><code>(validate-event x)</code></div><div class="doc"><pre class="plaintext">Returns nil if given argument is a valid [ev-id ?ev-data] form. Otherwise
returns a map of validation errors like `{:wrong-type {:expected _ :actual _}}`.</pre></div></div></div></body></html>